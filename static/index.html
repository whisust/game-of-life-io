<!DOCTYPE html>
<html>
<head>
    <title>Game of Life Multiplayer</title>
    <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }

        #gameCanvas {
            border: 2px solid #333;
            cursor: crosshair;
            display: block;
            margin: 10px auto;
            background-color: #000;
            image-rendering: pixelated; /* Pour un rendu net des pixels */
            max-width: 100%;
            box-sizing: border-box;
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            #gameCanvas {
                width: calc(100% - 20px); /* Take most of the width with small margin */
                height: auto;
                margin: 10px auto;
            }

            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 5px;
            }

            .controls {
                margin: 10px 0;
            }

            .controls button {
                margin: 3px;
                padding: 8px 12px;
                font-size: 14px;
            }

            /*.orientation-controls, .grid-size-controls, .game-controls {*/
            /*    display: flex;*/
            /*    flex-wrap: wrap;*/
            /*    justify-content: center;*/
            /*    margin-bottom: 10px;*/
            /*}*/

            .instructions {
                padding: 10px;
                margin: 10px auto;
            }

            .info {
                font-size: 14px;
                padding: 8px;
            }
        }

        .admin-controls {
            display: none;
        }

        .controls {
            margin: 20px 0;
            text-align: center;
        }

        button {
            margin: 5px;
            padding: 12px 16px;
            border: 2px solid #007acc;
            background-color: white;
            color: #007acc;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        button:hover {
            background-color: #007acc;
            color: white;
        }

        .selected {
            background-color: #007acc !important;
            color: white !important;
            font-weight: bold;
        }

        .info {
            margin: 10px 0;
            text-align: center;
            font-size: 16px;
            padding: 10px;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #status {
            font-weight: bold;
        }

        .instructions {
            margin: 20px auto;
            max-width: 600px;
            padding: 15px;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .instructions h3 {
            margin-top: 0;
            color: #333;
        }

        .instructions ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .instructions li {
            margin: 5px 0;
        }

        .pattern-info {
            margin: 10px 0;
            font-style: italic;
            color: #666;
        }
    </style>
</head>
<body>
<h1>üß¨ Game of Life Multijoueur</h1>

<div class="info">
    <span id="status">D√©connect√©</span> |
    G√©n√©ration: <span id="generation">0</span> |
    Joueurs: <span id="players">0</span>
</div>

<div class="controls">
    <div class="pattern-controls">
        <label>Pattern:</label>
        <button class="pattern-btn" onclick="selectPattern('glider')" title="Raccourci: 1">
            üöÄ Glider
        </button>
        <button class="pattern-btn" onclick="selectPattern('oscillator')" title="Raccourci: 2">
            ‚ö° Oscillateur
        </button>
        <button class="pattern-btn" onclick="selectPattern('spaceship')" title="Raccourci: 3">
            üõ∏ Vaisseau
        </button>
        <button class="pattern-btn" onclick="selectPattern('block')" title="Raccourci: 4">
            ‚¨ú Block
        </button>
        <button class="pattern-btn" onclick="selectPattern('pulsar')" title="Raccourci: 5">
            üí´ Pulsar
        </button>
        <button class="pattern-btn" onclick="selectPattern('glider_gun')" title="Raccourci: 6">
            üî´ Glider Gun
        </button>
        <button class="pattern-btn" onclick="selectPattern('eraser')" title="Raccourci: 0">
            üßΩ Eraser
        </button>
    </div>
    <div class="orientation-controls">
        <label>Orientation:</label>
        <button class="orientation-btn" onclick="selectOrientation('up')" id="orientUp" title="Raccourci: ‚Üë">‚¨ÜÔ∏è</button>
        <button class="orientation-btn" onclick="selectOrientation('right')" id="orientRight" title="Raccourci: ‚Üí">‚û°Ô∏è</button>
        <button class="orientation-btn" onclick="selectOrientation('down')" id="orientDown" title="Raccourci: ‚Üì">‚¨áÔ∏è</button>
        <button class="orientation-btn" onclick="selectOrientation('left')" id="orientLeft" title="Raccourci: ‚Üê">‚¨ÖÔ∏è</button>
    </div>
    <div class="grid-size-controls admin-controls">
        <label>Grille:</label>
        <button class="grid-btn" onclick="setGridSize(512)" id="grid512">512x512</button>
        <button class="grid-btn" onclick="setGridSize(256)" id="grid256">256x256</button>
        <button class="grid-btn" onclick="setGridSize(128)" id="grid128">128x128</button>
    </div>
    <div class="game-controls admin-controls">
        <button class="init-btn" onclick="initGame()" id="initBtn">üöÄ Initialize</button>
        <button class="pause-btn" onclick="pauseGame()" id="pauseBtn">‚è∏Ô∏è Pause</button>
        <button class="resume-btn" onclick="resumeGame()" id="resumeBtn">‚ñ∂Ô∏è Resume</button>
        <button class="reset-btn" onclick="resetGame()" id="resetBtn">üîÑ Reset</button>
        <button class="stop-btn" onclick="stopGame()" id="stopBtn">‚èπÔ∏è Stop</button>
    </div>
</div>

<canvas id="gameCanvas" width="512" height="512"></canvas>

<div class="instructions">
    <h3>üéÆ Comment jouer</h3>
    <ul>
        <li><strong>Cliquez</strong> sur la grille pour placer le pattern s√©lectionn√©</li>
        <li><strong>Touches 1-6</strong> pour changer rapidement de pattern</li>
        <li><strong>Touches fl√®ches</strong> (‚Üë, ‚Üí, ‚Üì, ‚Üê) pour changer l'orientation du pattern</li>
        <li><strong>Glider</strong> : Se d√©place en diagonal</li>
        <li><strong>Oscillateur</strong> : Alterne entre √©tats</li>
        <li><strong>Vaisseau</strong> : Se d√©place horizontalement</li>
        <li><strong>Block</strong> : Reste stable</li>
        <li><strong>Pulsar</strong> : Oscillateur complexe de p√©riode 3</li>
        <li><strong>Glider Gun</strong> : G√©n√®re des gliders p√©riodiquement</li>
    </ul>
</div>

<script>
    class GameOfLifeClient {
        static NOTES_FREQ = {
            // Lower octaves for bass notes
            'G2': 98.00, 'G#2': 103.83, 'Ab2': 103.83, 'A2': 110.00, 'A#2': 116.54,
            'Bb2': 116.54, 'B2': 123.47, 'C3': 130.81, 'C#3': 138.59, 'Db3': 138.59,
            'D3': 146.83, 'D#3': 155.56, 'Eb3': 155.56, 'E3': 164.81, 'F3': 174.61,
            'F#3': 185.00, 'Gb3': 185.00, 'G3': 196.00, 'G#3': 207.65, 'Ab3': 207.65,
            'A3': 220.00, 'A#3': 233.08, 'Bb3': 233.08, 'B3': 246.94,

            // Middle octave
            'C4': 261.63, 'C#4': 277.18, 'Db4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'Eb4': 311.13,
            'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'Gb4': 369.99, 'G4': 392.00, 'G#4': 415.30,
            'Ab4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'Bb4': 466.16, 'B4': 493.88,

            // Higher octave for lead sounds
            'C5': 523.25, 'C#5': 554.37, 'Db5': 554.37, 'D5': 587.33, 'D#5': 622.25, 'Eb5': 622.25,
            'E5': 659.26, 'F5': 698.46, 'F#5': 739.99, 'Gb5': 739.99, 'G5': 783.99
        };

        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.ws = null;
            this.player = null;
            this.selectedPattern = 'glider';
            this.selectedOrientation = 'up'; // Default orientation
            this.gridSize = 128; // Default grid size
            this.canvasSize = 512; // Fixed canvas size
            this.cellSize = this.canvasSize / this.gridSize; // Calculate cell size based on grid size
            this.gameState = null;
            this.isConnected = false;

            // Sound feature
            this.audioContext = null;
            this.soundEnabled = false;
            this.soundGridRows = 8; // 8 rows for instruments
            this.soundGridCols = 16; // 16 columns for beats
            this.soundSquareWidth = this.canvasSize / this.soundGridCols;
            this.soundSquareHeight = this.canvasSize / this.soundGridRows;
            this.bpm = 120; // 120 beats per minute
            this.currentBeat = 0;
            this.isPlaying = false;
            this.soundTimer = null;

            // Define instrument types for each row
            this.instruments = [
                'drum',    // Row 0: Drum
                'clap',    // Row 1: Clap
                'hats',    // Row 2: Hats
                'percussion', // Row 3: Percussion
                'groove',  // Row 4: Groove
                'bass',    // Row 5: Bass
                'melody',  // Row 6: Simple melody with chords
                // 'choir',    // Row 7: Choirs
                'synth',    // Row 7: Choirs
            ];

            // Notes for each instrument (row)
            this.notes = {
                // Row 0: Drum (just one note, as we'll use the 909 kick)
                'drum': Array(16).fill('C2'),

                // Row 1: Clap (just one note, as we'll use the 909 clap)
                'clap': [null, 'D2', null, 'D2', null, 'D2', null, 'D2', null, 'D2', null, 'D2', null, 'D2', null, 'D2'],

                // Row 2: Hats (just one note, as we'll use the 909 hi-hat)
                'hats': [null, 'E2', null, 'E2', null, 'E2', null, 'E2', null, 'E2', null, 'E2', null, 'E2', null, 'E2'],

                // Row 3: Percussion (various percussion sounds)
                'percussion': Array(16).fill('F2'),

                // Row 4: Groove (bassline groove in G minor)
                'groove': ['G2', 'D3', 'G2', 'Bb2', 'G2', 'D3', 'G2', 'C3', 'G2', 'D3', 'G2', 'Bb2', 'G2', 'D3', 'G2', 'F3'],

                // Row 5: Bass (deep bass notes in G minor)
                'bass': ['G1', 'G1', null, 'Bb1', 'C2', 'C2', null, 'D2', 'G1', null, 'Bb1', 'Bb1', null, 'C2', 'D2', 'F2'],

                // Row 6: Melody (simple melody with chord notes in G minor)
                'melody': ['G4', null, 'D4', 'G4', null, 'Bb4', 'D4', 'F4', null, 'G4', 'Bb4', null, 'D4', 'F4', null, 'D4'],

                // Row 7: Choirs (choir-like pads in G minor)
                'synth': [null, 'Bb3', 'D3', null, 'F3', 'Bb3', 'D3', null, null, 'G3', 'Bb3', 'Eb3', 'D3', null, 'Bb3', 'D3']
            };

            this.setupCanvas();
            this.setupEventListeners();
            this.setupAudio();
            this.connect();

            // Highlight default grid size button
            document.getElementById(`grid${this.gridSize}`).classList.add('selected');
            // Highlight default orientation button
            document.getElementById('orientUp').classList.add('selected');
        }

        setupAudio() {
            try {
                // Initialize Web Audio API
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('Audio context initialized');

                // Create a toggle button for sound
                const soundToggle = document.createElement('button');
                soundToggle.textContent = 'üîá Sound Off';
                soundToggle.id = 'soundToggle';
                soundToggle.classList.add('sound-toggle');
                soundToggle.onclick = () => this.toggleSound();

                // Add the button to the controls
                const controls = document.querySelector('.controls');
                controls.appendChild(soundToggle);

                // Add style for the sound toggle button
                const style = document.createElement('style');
                style.textContent = `
                    .sound-toggle {
                        margin: 5px;
                        padding: 12px 16px;
                        border: 2px solid #007acc;
                        background-color: white;
                        color: #007acc;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: bold;
                        transition: all 0.2s;
                    }
                    .sound-toggle:hover {
                        background-color: #007acc;
                        color: white;
                    }
                    .sound-toggle.active {
                        background-color: #007acc;
                        color: white;
                    }
                `;
                document.head.appendChild(style);
            } catch (e) {
                console.error('Web Audio API is not supported in this browser', e);
            }
        }

        toggleSound() {
            this.soundEnabled = !this.soundEnabled;
            const soundToggle = document.getElementById('soundToggle');

            if (this.soundEnabled) {
                soundToggle.textContent = 'üîä Sound On';
                soundToggle.classList.add('active');

                // Resume audio context if it was suspended
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }

                // Start the sound loop if not already playing
                if (!this.isPlaying) {
                    this.startSoundLoop();
                }
            } else {
                soundToggle.textContent = 'üîá Sound Off';
                soundToggle.classList.remove('active');

                // Stop the sound loop
                this.stopSoundLoop();
            }
        }

        startSoundLoop() {
            if (!this.soundEnabled || this.isPlaying) return;

            this.isPlaying = true;
            this.currentBeat = 0;

            // Calculate beat duration in milliseconds (60000 ms / BPM)
            const beatDuration = 60000 / this.bpm;

            // Start the loop
            this.playCurrentBeat();
            this.soundTimer = setInterval(() => {
                this.currentBeat = (this.currentBeat + 1) % this.soundGridCols; // 16 beats in the loop
                this.playCurrentBeat();
            }, beatDuration);
        }

        stopSoundLoop() {
            if (this.soundTimer) {
                clearInterval(this.soundTimer);
                this.soundTimer = null;
            }
            this.isPlaying = false;
        }

        playCurrentBeat() {
            if (!this.soundEnabled || !this.audioContext || !this.gameState) return;

            // Play all instruments in the current column
            for (let row = 0; row < this.soundGridRows; row++) {
                this.playSquareSound(row, this.currentBeat);
            }

            // Re-render to update the highlighted column
            this.render();
        }

        playSquareSound(row, col) {
            // Safety check
            if (row >= this.soundGridRows || col >= this.soundGridCols) return;

            // Count alive cells in this square
            const aliveCells = this.countAliveCellsInSquare(row, col);
            if (aliveCells === 0) return; // Don't play sound if no cells are alive

            // Get the instrument type for this row
            const instrument = this.instruments[row];

            // Get the note for this instrument and column
            const note = this.notes[instrument][col];

            if(note) {
                // Calculate frequency based on the note
                const frequency = this.noteToFrequency(note);

                // Calculate volume based on alive cells (normalize to 0-1 range)
                // Assuming a maximum of (squareWidth*squareHeight/cellSize^2) cells in a square
                const maxCells = Math.pow(this.soundSquareWidth * this.soundSquareHeight / (this.cellSize * this.cellSize), 1);
                const volume = Math.min(0.8, 0.1 + (aliveCells / maxCells) * 0.7);

                // Play the sound based on the instrument type
                this.playInstrument(instrument, frequency, volume);
            }
        }

        noteToFrequency(note) {
            // Extended mapping of notes to frequencies (A4 = 440Hz)
            return GameOfLifeClient.NOTES_FREQ[note] || 440; // Default to A4 if note not found
        }

        playInstrument(instrument, frequency, volume) {
            if (!this.audioContext) return;

            switch (instrument) {
                case 'drum':
                    this.play909Kick(volume);
                    break;
                case 'clap':
                    this.play909Clap(volume);
                    break;
                case 'hats':
                    this.play909HiHat(volume);
                    break;
                case 'percussion':
                    this.playPercussion(volume);
                    break;
                case 'groove':
                    this.playGroove(frequency, volume);
                    break;
                case 'bass':
                    this.playBass(frequency, volume);
                    break;
                case 'melody':
                    this.playMelody(frequency, volume);
                    break;
                case 'choir':
                    this.playChoir(frequency, volume);
                    break;
                case 'synth':
                    this.playDaftPunkSynth(frequency, volume);
                default:
                    this.playDaftPunkSynth(frequency, volume);
            }
        }

        play909Kick(volume) {
            // Create a 909-style kick drum sound
            const osc = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            const now = this.audioContext.currentTime;

            // Set up oscillator for the kick
            osc.type = 'sine';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.5);

            // Set up gain envelope for the kick
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.005);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.4);

            // Connect and start
            osc.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            osc.start(now);
            osc.stop(now + 0.5);
        }

        play909Snare(volume) {
            // Create a 909-style snare drum sound
            const noiseNode = this.createNoiseNode(0.2);
            const oscNode = this.audioContext.createOscillator();
            const noiseGain = this.audioContext.createGain();
            const oscGain = this.audioContext.createGain();
            const now = this.audioContext.currentTime;

            // Set up oscillator component
            oscNode.type = 'triangle';
            oscNode.frequency.value = 180;

            // Set up gain envelopes
            noiseGain.gain.setValueAtTime(0, now);
            noiseGain.gain.linearRampToValueAtTime(volume, now + 0.005);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

            oscGain.gain.setValueAtTime(0, now);
            oscGain.gain.linearRampToValueAtTime(volume * 0.5, now + 0.005);
            oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

            // Connect and start
            noiseNode.connect(noiseGain);
            oscNode.connect(oscGain);
            noiseGain.connect(this.audioContext.destination);
            oscGain.connect(this.audioContext.destination);

            oscNode.start(now);
            oscNode.stop(now + 0.2);
        }

        play909HiHat(volume) {
            // Create a 909-style hi-hat sound
            const noiseNode = this.createNoiseNode(0.05);
            const gainNode = this.audioContext.createGain();
            const highpassFilter = this.audioContext.createBiquadFilter();
            const now = this.audioContext.currentTime;

            // Set up filter
            highpassFilter.type = 'highpass';
            highpassFilter.frequency.value = 7000;
            highpassFilter.Q.value = 1;

            // Set up gain envelope
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume * 0.8, now + 0.001);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);

            // Connect and start
            noiseNode.connect(highpassFilter);
            highpassFilter.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
        }

        play909Clap(volume) {
            // Create a 909-style clap sound
            const noiseNode = this.createNoiseNode(0.3);
            const gainNode = this.audioContext.createGain();
            const bandpassFilter = this.audioContext.createBiquadFilter();
            const now = this.audioContext.currentTime;

            // Set up filter for clap sound
            bandpassFilter.type = 'bandpass';
            bandpassFilter.frequency.value = 1200;
            bandpassFilter.Q.value = 0.7;

            // Set up gain envelope with a slight delay for clap effect
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.02);
            gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.03);
            gainNode.gain.linearRampToValueAtTime(volume * 0.7, now + 0.04);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

            // Connect and start
            noiseNode.connect(bandpassFilter);
            bandpassFilter.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
        }

        playPercussion(volume) {
            // Create a percussion sound (like a conga or bongo)
            const osc = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            const bandpassFilter = this.audioContext.createBiquadFilter();
            const now = this.audioContext.currentTime;

            // Set up oscillator for percussion
            osc.type = 'triangle';
            osc.frequency.value = 220;

            // Set up filter
            bandpassFilter.type = 'bandpass';
            bandpassFilter.frequency.value = 800;
            bandpassFilter.Q.value = 2;

            // Set up gain envelope for short percussive sound
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.005);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

            // Connect and start
            osc.connect(bandpassFilter);
            bandpassFilter.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            osc.start(now);
            osc.stop(now + 0.2);
        }

        playGroove(frequency, volume) {
            // Create a groovy synth sound with rhythm
            const osc = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            const lowpassFilter = this.audioContext.createBiquadFilter();
            const now = this.audioContext.currentTime;

            // Set up oscillator
            osc.type = 'sawtooth';
            osc.frequency.value = frequency;

            // Set up filter
            lowpassFilter.type = 'lowpass';
            lowpassFilter.frequency.value = 1200;
            lowpassFilter.Q.value = 5;

            // Set up gain envelope with groove feel
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
            gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.1);
            gainNode.gain.linearRampToValueAtTime(volume * 0.8, now + 0.15);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

            // Connect and start
            osc.connect(lowpassFilter);
            lowpassFilter.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            osc.start(now);
            osc.stop(now + 0.3);
        }

        playBass(frequency, volume) {
            // Create a deep bass sound
            const osc1 = this.audioContext.createOscillator();
            const osc2 = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            const lowpassFilter = this.audioContext.createBiquadFilter();
            const distortion = this.createDistortionEffect(5); // Subtle distortion
            const now = this.audioContext.currentTime;

            // Set up oscillators for bass
            osc1.type = 'sine';
            osc1.frequency.value = frequency;

            osc2.type = 'triangle';
            osc2.frequency.value = frequency * 2; // One octave higher for harmonics

            // Set up filter
            lowpassFilter.type = 'lowpass';
            lowpassFilter.frequency.value = 500;
            lowpassFilter.Q.value = 1;

            // Set up gain envelope for bass
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.02);
            gainNode.gain.linearRampToValueAtTime(volume * 0.8, now + 0.3);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

            // Connect and start
            osc1.connect(distortion);
            osc2.connect(distortion);
            distortion.connect(lowpassFilter);
            lowpassFilter.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            osc1.start(now);
            osc2.start(now);
            osc1.stop(now + 0.6);
            osc2.stop(now + 0.6);
        }

        playMelody(frequency, volume) {
            // Create a melodic synth sound with chords
            const osc1 = this.audioContext.createOscillator();
            const osc2 = this.audioContext.createOscillator();
            const osc3 = this.audioContext.createOscillator(); // For chord
            const gainNode = this.audioContext.createGain();
            const filter = this.audioContext.createBiquadFilter();
            const now = this.audioContext.currentTime;

            // Set up oscillators for melody with chord
            osc1.type = 'sawtooth';
            osc1.frequency.value = frequency;

            osc2.type = 'square';
            osc2.frequency.value = frequency * 1.005; // Slight detuning

            osc3.type = 'sawtooth';
            osc3.frequency.value = frequency * 1.5; // Perfect fifth for chord

            // Set up filter
            filter.type = 'bandpass';
            filter.frequency.value = 2000;
            filter.Q.value = 2;

            // Set up gain envelope
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume * 0.7, now + 0.05);
            gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.2);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

            // Connect and start
            osc1.connect(filter);
            osc2.connect(filter);
            osc3.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            osc1.start(now);
            osc2.start(now);
            osc3.start(now);
            osc1.stop(now + 0.4);
            osc2.stop(now + 0.4);
            osc3.stop(now + 0.4);
        }

        playChoir(frequency, volume) {
            // Create a choir-like pad sound
            const osc1 = this.audioContext.createOscillator();
            const osc2 = this.audioContext.createOscillator();
            const osc3 = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            const filter = this.audioContext.createBiquadFilter();
            const now = this.audioContext.currentTime;

            // Set up oscillators for choir sound
            osc1.type = 'sine';
            osc1.frequency.value = frequency;

            osc2.type = 'sine';
            osc2.frequency.value = frequency * 1.003; // Slight detuning for chorus effect

            osc3.type = 'sine';
            osc3.frequency.value = frequency * 0.997; // Slight detuning in other direction

            // Set up filter
            filter.type = 'lowpass';
            filter.frequency.value = 2000;
            filter.Q.value = 1;

            // Set up gain envelope for pad sound
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.1); // Slow attack
            gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.3);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.8); // Long release

            // Connect and start
            osc1.connect(filter);
            osc2.connect(filter);
            osc3.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            osc1.start(now);
            osc2.start(now);
            osc3.start(now);
            osc1.stop(now + 0.8);
            osc2.stop(now + 0.8);
            osc3.stop(now + 0.8);
        }

        playDaftPunkSynth(frequency, volume) {
            // Create a Daft Punk-esque synth sound with more authentic processing
            const osc1 = this.audioContext.createOscillator();
            const osc2 = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            const lowpassFilter = this.audioContext.createBiquadFilter();
            const distortion = this.createDistortionEffect(20); // Subtle distortion
            const now = this.audioContext.currentTime;

            // Set up oscillators
            osc1.type = 'sawtooth';
            osc1.frequency.value = frequency;

            osc2.type = 'square';
            osc2.frequency.value = frequency * 1.005; // Slight detuning for thickness

            // Add a third oscillator for sub-bass (one octave lower)
            const subOsc = this.audioContext.createOscillator();
            subOsc.type = 'sine';
            subOsc.frequency.value = frequency / 2;
            const subGain = this.audioContext.createGain();
            subGain.gain.value = volume * 0.5;

            // Set up more dramatic filter envelope (classic Daft Punk filter sweep)
            lowpassFilter.type = 'lowpass';
            lowpassFilter.frequency.setValueAtTime(200, now); // Start with closed filter
            lowpassFilter.frequency.exponentialRampToValueAtTime(1500, now + 0.1); // Quick opening
            lowpassFilter.frequency.exponentialRampToValueAtTime(800, now + 0.3); // Slow closing
            lowpassFilter.Q.value = 12; // More resonance for that Daft Punk sound

            // Set up gain envelope with slight pumping effect
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume * 0.8, now + 0.01);
            gainNode.gain.setValueAtTime(volume * 0.8, now + 0.1);
            gainNode.gain.linearRampToValueAtTime(volume * 0.6, now + 0.15); // Slight dip
            gainNode.gain.linearRampToValueAtTime(volume * 0.7, now + 0.2); // Rise again
            gainNode.gain.linearRampToValueAtTime(0, now + 0.4); // Longer release

            // Connect everything
            osc1.connect(distortion);
            osc2.connect(distortion);
            subOsc.connect(subGain);
            distortion.connect(lowpassFilter);
            subGain.connect(lowpassFilter);
            lowpassFilter.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            // Start and stop oscillators
            osc1.start(now);
            osc2.start(now);
            subOsc.start(now);
            osc1.stop(now + 0.4);
            osc2.stop(now + 0.4);
            subOsc.stop(now + 0.4);
        }

        createDistortionEffect(amount) {
            // Create a waveshaper distortion effect
            const distortion = this.audioContext.createWaveShaper();

            // Create the distortion curve
            const k = typeof amount === 'number' ? amount : 50;
            const samples = 44100;
            const curve = new Float32Array(samples);
            const deg = Math.PI / 180;

            for (let i = 0; i < samples; ++i) {
                const x = i * 2 / samples - 1;
                // Distortion formula
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }

            distortion.curve = curve;
            distortion.oversample = '4x';

            return distortion;
        }

        createNoiseNode(duration) {
            // Create a buffer of white noise
            const bufferSize = this.audioContext.sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            // Create audio buffer source node
            const noise = this.audioContext.createBufferSource();
            noise.buffer = buffer;
            noise.start();

            return noise;
        }

        countAliveCellsInSquare(row, col) {
            if (!this.gameState) return 0;

            let count = 0;
            const startX = col * this.soundSquareWidth;
            const startY = row * this.soundSquareHeight;
            const endX = startX + this.soundSquareWidth;
            const endY = startY + this.soundSquareHeight;

            // Convert pixel coordinates to grid coordinates
            const gridStartX = Math.floor(startX / this.cellSize);
            const gridStartY = Math.floor(startY / this.cellSize);
            const gridEndX = Math.ceil(endX / this.cellSize);
            const gridEndY = Math.ceil(endY / this.cellSize);

            // Count alive cells in this region
            for (let y = gridStartY; y < gridEndY && y < this.gridSize; y++) {
                for (let x = gridStartX; x < gridEndX && x < this.gridSize; x++) {
                    if (this.gameState.grid[y] && this.gameState.grid[y][x]) {
                        count++;
                    }
                }
            }

            return count;
        }

        setupCanvas() {
            // Set the canvas size based on device
            this.updateCanvasSize();

            // Handle window resize events
            window.addEventListener('resize', () => {
                this.updateCanvasSize();
                // Re-render if we have game state
                if (this.gameState) {
                    this.render();
                }
            });

            // Canvas noir par d√©faut
            this.ctx.fillStyle = '#000000';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        updateCanvasSize() {
            // For mobile, use responsive sizing
            if (window.innerWidth <= 768) {
                // Let CSS handle the display size
                // But keep the internal canvas dimensions fixed for game logic
                this.canvas.width = 512;
                this.canvas.height = 512;
            } else {
                // For desktop, use fixed size
                this.canvas.width = 512;
                this.canvas.height = 512;
                this.canvas.style.width = '512px';
                this.canvas.style.height = '512px';
            }
        }

        setupEventListeners() {
            this.canvas.addEventListener('click', (e) => {
                if (!this.isConnected || !this.player) return;

                const rect = this.canvas.getBoundingClientRect();
                // Calculate the scaling factor between display size and internal canvas size
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;

                // Calculate the position in the internal canvas coordinates
                const canvasX = (e.clientX - rect.left) * scaleX;
                const canvasY = (e.clientY - rect.top) * scaleY;

                // Convert to grid coordinates
                const x = Math.floor(canvasX * (this.gridSize / this.canvas.width));
                const y = Math.floor(canvasY * (this.gridSize / this.canvas.height));

                this.placePattern(x, y);
            });

            // Add touch support for mobile devices
            this.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling when touching the canvas
            });

            this.canvas.addEventListener('touchend', (e) => {
                if (!this.isConnected || !this.player || !e.changedTouches[0]) return;

                const touch = e.changedTouches[0];
                const rect = this.canvas.getBoundingClientRect();

                // Calculate the scaling factor between display size and internal canvas size
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;

                // Calculate the position in the internal canvas coordinates
                const canvasX = (touch.clientX - rect.left) * scaleX;
                const canvasY = (touch.clientY - rect.top) * scaleY;

                // Convert to grid coordinates
                const x = Math.floor(canvasX * (this.gridSize / this.canvas.width));
                const y = Math.floor(canvasY * (this.gridSize / this.canvas.height));

                this.placePattern(x, y);
                e.preventDefault();
            });

            // Emp√™cher le menu contextuel sur clic droit
            this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        setGridSize(size) {
            this.gridSize = size;
            this.cellSize = this.canvasSize / this.gridSize;

            // Update UI
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.classList.remove('selected');
            });

            document.getElementById(`grid${size}`).classList.add('selected');

            // Re-render if we have game state
            if (this.gameState) {
                this.render();
            }
        }

        connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/game-of-life/ws`;

            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
                console.log('Connexion WebSocket ouverte');
                this.updateStatus('Connexion...');

                // Rejoindre le jeu
                const playerName = prompt('Entrez votre nom:') || 'Anonyme';

                // Update UI based on admin status
                this.updateUIVisibility();

                this.ws.send(JSON.stringify({
                    type: 'join',
                    name: playerName
                }));
            };

            this.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                this.handleMessage(data);
            };

            this.ws.onclose = () => {
                console.log('Connexion WebSocket ferm√©e');
                this.isConnected = false;
                this.updateStatus('D√©connect√©');

                // Tentative de reconnexion apr√®s 3 secondes
                setTimeout(() => {
                    if (!this.isConnected) {
                        console.log('Tentative de reconnexion...');
                        this.connect();
                    }
                }, 3000);
            };

            this.ws.onerror = (error) => {
                console.error('Erreur WebSocket:', error);
                this.updateStatus('Erreur de connexion');
            };
        }

        handleMessage(data) {
            switch (data.type) {
                case 'joined':
                    this.player = {
                        id: data.player.id,
                        name: data.player.name,
                        isAdmin: data.player.is_admin
                    };
                    this.isConnected = true;
                    this.setGridSize(data.grid_size);
                    this.updateStatus('Connect√©');
                    console.log('Rejoint le jeu:', data.message);
                    // Update UI visibility based on admin status
                    this.updateUIVisibility();
                    break;

                case 'game_state':
                    this.gameState = data;
                    this.render();
                    this.updateUI();

                    // Start sound loop if enabled and not already playing
                    if (this.soundEnabled && !this.isPlaying) {
                        this.startSoundLoop();
                    }
                    break;

                case 'game_initialized':
                    console.log('Game has been initialized:', data.message);
                    this.setGridSize(data.grid_size);
                    document.getElementById('generation').textContent = '0';
                    document.getElementById('players').textContent = data.players_count;

                    // Start sound loop if enabled and not already playing
                    if (this.soundEnabled && !this.isPlaying) {
                        this.startSoundLoop();
                    }
                    break;

                case 'game_reset':
                    console.log('Game has been reset:', data.message);
                    this.setGridSize(data.grid_size);
                    document.getElementById('generation').textContent = '0';
                    document.getElementById('players').textContent = data.players_count;

                    // Restart sound loop if enabled
                    if (this.soundEnabled) {
                        this.stopSoundLoop();
                        this.startSoundLoop();
                    }
                    break;

                case 'game_paused':
                    console.log('Game has been paused:', data.message);
                    // Pause sound loop
                    this.stopSoundLoop();
                    break;

                case 'game_resumed':
                    console.log('Game has been resumed:', data.message);
                    // Resume sound loop if enabled
                    if (this.soundEnabled) {
                        this.startSoundLoop();
                    }
                    break;

                case 'game_stopped':
                    console.log('Game has been stopped:', data.message);
                    // Update UI to show stopped state
                    this.render();
                    this.updateUI();

                    // Stop sound loop
                    this.stopSoundLoop();
                    break;

                default:
                    console.log('Message non g√©r√©:', data);
            }
        }

        placePattern(x, y) {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

            this.ws.send(JSON.stringify({
                type: 'place_pattern',
                pattern: this.selectedPattern,
                orientation: this.selectedOrientation,
                x: x,
                y: y
            }));
        }

        initGame() {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

            this.ws.send(JSON.stringify({
                type: 'init_game',
                grid_size: this.gridSize
            }));
            console.log(`Initialize game command sent with grid size ${this.gridSize}`);
        }

        pauseGame() {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

            this.ws.send(JSON.stringify({
                type: 'pause_game'
            }));
            console.log('Pause game command sent');
        }

        resumeGame() {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

            this.ws.send(JSON.stringify({
                type: 'resume_game'
            }));
            console.log('Resume game command sent');
        }

        resetGame() {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

            this.ws.send(JSON.stringify({
                type: 'reset_game',
                grid_size: this.gridSize
            }));
            console.log('Reset game command sent');
        }

        stopGame() {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

            this.ws.send(JSON.stringify({
                type: 'stop_game'
            }));
            console.log('Stop game command sent');
        }

        selectOrientation(orientation) {
            this.selectedOrientation = orientation;

            // Update visual indication of selected orientation
            document.querySelectorAll('.orientation-btn').forEach(btn => {
                btn.classList.remove('selected');
            });

            document.getElementById(`orient${orientation.charAt(0).toUpperCase() + orientation.slice(1)}`).classList.add('selected');
        }

        render() {
            if (!this.gameState) return;

            // Clear the canvas
            this.ctx.fillStyle = '#000000';
            this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);

            // Set cell color
            this.ctx.fillStyle = '#FFFFFF';

            // Draw cells based on cell size
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    const isAlive = this.gameState.grid[y][x];

                    if (isAlive) {
                        // Calculate position based on cell size
                        const pixelX = x * this.cellSize;
                        const pixelY = y * this.cellSize;

                        // Draw the cell
                        this.ctx.fillRect(pixelX, pixelY, this.cellSize, this.cellSize);
                    }
                }
            }

            // Draw sound grid if sound is enabled
            if (this.soundEnabled) {
                this.drawSoundGrid();
            }
        }

        drawSoundGrid() {
            // Draw the 8x16 grid for sound visualization
            this.ctx.strokeStyle = 'rgba(0, 122, 204, 0.5)'; // Semi-transparent blue
            this.ctx.lineWidth = 2;

            // Draw horizontal lines
            for (let i = 1; i < this.soundGridRows; i++) {
                const y = i * this.soundSquareHeight;
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.canvasSize, y);
                this.ctx.stroke();
            }

            // Draw vertical lines
            for (let i = 1; i < this.soundGridCols; i++) {
                const x = i * this.soundSquareWidth;
                this.ctx.beginPath();
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, this.canvasSize);
                this.ctx.stroke();
            }

            // Draw instrument names on the left side
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Semi-transparent white
            this.ctx.font = '12px Arial';
            this.ctx.textAlign = 'left';
            this.ctx.textBaseline = 'middle';

            // for (let row = 0; row < this.soundGridRows; row++) {
            //     const y = row * this.soundSquareHeight + this.soundSquareHeight / 2;
            //     // Capitalize first letter of instrument name
            //     const instrumentName = this.instruments[row].charAt(0).toUpperCase() + this.instruments[row].slice(1);
            //     this.ctx.fillText(instrumentName, 5, y);
            // }

            // Highlight the current beat column
            if (this.isPlaying) {
                this.highlightBeatColumn(this.currentBeat);
            }

            // Draw grid cells with active notes
            for (let row = 0; row < this.soundGridRows; row++) {
                for (let col = 0; col < this.soundGridCols; col++) {
                    // Count alive cells in this square
                    const aliveCells = this.countAliveCellsInSquare(row, col);
                    if (aliveCells > 0) {
                        // Draw a semi-transparent highlight for active cells
                        const intensity = Math.min(0.6, 0.1 + (aliveCells / 100) * 0.5);
                        this.ctx.fillStyle = `rgba(0, 255, 0, ${intensity})`; // Green with variable opacity
                        const x = col * this.soundSquareWidth;
                        const y = row * this.soundSquareHeight;
                        this.ctx.fillRect(x, y, this.soundSquareWidth, this.soundSquareHeight);
                    }
                }
            }
        }

        highlightBeatColumn(col) {
            if (col >= this.soundGridCols) return;

            const x = col * this.soundSquareWidth;

            // Draw a semi-transparent highlight for the entire column
            this.ctx.fillStyle = 'rgba(0, 122, 204, 0.3)'; // Light blue
            this.ctx.fillRect(x, 0, this.soundSquareWidth, this.canvasSize);

            // Draw beat number at the top
            // this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; // Almost white
            // this.ctx.font = '12px Arial';
            // this.ctx.textAlign = 'center';
            // this.ctx.textBaseline = 'top';
            // this.ctx.fillText(
            //     (col + 1).toString(),
            //     x + this.soundSquareWidth / 2,
            //     5
            // );

            // Highlight each active cell in the column
            for (let row = 0; row < this.soundGridRows; row++) {
                // Count alive cells in this square
                const aliveCells = this.countAliveCellsInSquare(row, col);
                if (aliveCells > 0) {
                    const y = row * this.soundSquareHeight;

                    // Draw a brighter highlight for active cells in the current column
                    this.ctx.fillStyle = 'rgba(255, 255, 0, 0.2)'; // Yellow highlight
                    this.ctx.fillRect(x, y, this.soundSquareWidth, this.soundSquareHeight);

                    // // Draw the note name in the square
                    // this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; // Almost white
                    // this.ctx.font = '10px Arial';
                    // this.ctx.textAlign = 'center';
                    // this.ctx.textBaseline = 'middle';

                    // // Get the note for this instrument and column
                    // const instrument = this.instruments[row];
                    // const note = this.notes[instrument][col];
                    //
                    // this.ctx.fillText(
                    //     note,
                    //     x + this.soundSquareWidth / 2,
                    //     y + this.soundSquareHeight / 2
                    // );
                }
            }
        }

        updateUI() {
            if (!this.gameState) return;

            document.getElementById('generation').textContent = this.gameState.generation;
            document.getElementById('players').textContent = this.gameState.players_count;
        }

        updateStatus(status) {
            document.getElementById('status').textContent = status;

            // Couleur selon le statut
            const statusEl = document.getElementById('status');
            statusEl.style.color = this.isConnected ? '#00aa00' : '#aa0000';
        }

        updateUIVisibility() {
            // Show/hide controls
            const adminControls = document.querySelectorAll('.admin-controls');
            adminControls.forEach(el => el.style.display = this.player?.isAdmin ? 'block' : 'none');
        }

        selectPattern(pattern) {
            this.selectedPattern = pattern;

            // Mise √† jour visuelle des boutons
            document.querySelectorAll('.pattern-btn').forEach(btn => {
                btn.classList.remove('selected');
            });

            // Add selected class to the button for the selected pattern
            document.querySelector(`.pattern-btn[onclick*="selectPattern('${pattern}')"]`).classList.add('selected');
        }
    }

    // Fonction globale pour la s√©lection de pattern
    function selectPattern(pattern) {
        if (window.gameClient) {
            window.gameClient.selectPattern(pattern);
        }
    }

    // Fonction globale pour la s√©lection d'orientation
    function selectOrientation(orientation) {
        if (window.gameClient) {
            window.gameClient.selectOrientation(orientation);
        }
    }

    // Fonction globale pour changer la taille de la grille
    function setGridSize(size) {
        if (window.gameClient) {
            window.gameClient.setGridSize(size);
        }
    }

    // Fonction globale pour initialiser le jeu
    function initGame() {
        if (window.gameClient) {
            window.gameClient.initGame();
        }
    }

    // Fonction globale pour mettre en pause le jeu
    function pauseGame() {
        if (window.gameClient) {
            window.gameClient.pauseGame();
        }
    }

    // Fonction globale pour reprendre le jeu
    function resumeGame() {
        if (window.gameClient) {
            window.gameClient.resumeGame();
        }
    }

    // Fonction globale pour r√©initialiser le jeu
    function resetGame() {
        if (window.gameClient) {
            window.gameClient.resetGame();
        }
    }

    // Fonction globale pour arr√™ter le jeu
    function stopGame() {
        if (window.gameClient) {
            window.gameClient.stopGame();
        }
    }

    // Initialiser le client au chargement de la page
    window.addEventListener('DOMContentLoaded', () => {
        window.gameClient = new GameOfLifeClient();

        // S√©lectionner le premier pattern par d√©faut
        setTimeout(() => {
            document.querySelector('.pattern-btn').click();
        }, 100);
    });

    // Gestion des raccourcis clavier
    document.addEventListener('keydown', (e) => {
        if (!window.gameClient) return;

        switch(e.key) {
            // Pattern selection
            case '1':
                selectPattern('glider');
                break;
            case '2':
                selectPattern('oscillator');
                break;
            case '3':
                selectPattern('spaceship');
                break;
            case '4':
                selectPattern('block');
                break;
            case '5':
                selectPattern('pulsar');
                break;
            case '6':
                selectPattern('glider_gun');
                break;
            case '0':
                selectPattern('eraser');
                break;

            // Orientation selection with arrow keys
            case 'ArrowUp':
                selectOrientation('up');
                e.preventDefault(); // Prevent page scrolling
                break;
            case 'ArrowRight':
                selectOrientation('right');
                e.preventDefault();
                break;
            case 'ArrowDown':
                selectOrientation('down');
                e.preventDefault();
                break;
            case 'ArrowLeft':
                selectOrientation('left');
                e.preventDefault();
                break;
        }
    });
</script>
</body>
</html>
